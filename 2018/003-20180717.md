# ARTS
 [Algorithm](#1-algorithm)

 [Review](#1-review)

 [Tip](#3-tip)

 [Share](#4-share)
 
## 1. Algorithm

> 项目地址：[33. Search in Rotated Sorted Array]( https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/ )

这道题是来自英杰的ARTS7.29日的A，[zouyingjie 第六周 arts](https://github.com/zouyingjie/arts/blob/master/2018-07-29.md#一-algorithms)
开始觉得本该挺复杂的，不过初次看他写的太过简单很纳闷。补充中他也指出了是要用二分查找来做，这一点提醒了我。不然我还真不理解
如何才能做到O(logN)。
```  cpp
#include <stdio.h>
int search(int *nums, int numsSize, int target) {
    int low, high, mid;
    low = 0;
    high = numsSize - 1;
    mid = (numsSize - 1) / 2;
    if (nums[0] < target) {
        // In Left Side: index is  0  to MaxNumIndex.
        while (low <= high) {
            if (target == nums[low]) return low;
            if (target == nums[high]) return high;
            if (nums[mid] == target) return mid;
            if (nums[low] < nums[mid]) {			// different
                if (nums[mid] < target) { low = mid + 1; };
                if (nums[mid] > target) { high = mid - 1; };
            } else {
                // mid to numsSize have root point.continue Binary search.
                high = mid - 1;					// different
            }
            mid = (low + high) / 2;
        }
    } else {
        // In Right Side: index is MaxNumIndex to numsSize-1.
        while (low <= high) {
            if (target == nums[low]) return low;
            if (target == nums[high]) return high;
            if (nums[mid] == target) return mid;
            if (nums[mid] < nums[high]) {		// different
                if (nums[mid] < target)low = mid + 1;		// different
                if (nums[mid] > target)high = mid - 1;
            } else {
                // mid to numsSize have root point.continue Binary search.
                low = mid + 1;				// different
            }
            mid = (low + high) / 2;	
        }
    }
    return -1;
}

int main() {
    int result;
//    int  nums[7]= {4, 5, 6, 7, 0, 1, 2};
    int nums[5] = {3, 4, 5, 1, 2};
    int target = 4;
    result = search(nums, 5, target);
    printf("Find %d in nums is %d \n", target, result);
    return 0;
}
```
在看过英杰的思路后，只是单纯觉得旋转已经算是一次切分了，应该基于这一点来思考算法，同时知道二分法可以做，只是一直写不出来。
实在无奈只有去leetcode.com 看了看各路大神的思路，真是牛，各种仙技。结合自己能力，选择了其中理解了的和起初思路一致的
[Clever-idea-making-it-simple](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14435/Clever-idea-making-it-simple)
，对旋转算一次切分，切分后分别用二分查找来做。但是做的过程还是很不顺畅。对C语言本身熟练度不够，还是继续好好打基础，撸教程、实验的先。


## 2. Review

- 原文地址：[a leetcode grinding guide](https://www.reddit.com/r/cscareerquestions/comments/6luszf/a_leetcode_grinding_guide/ )



## 3. Tip

[weiboscrapper1的ARTS](https://github.com/weiboscrapper1/ARTS/blob/master/week29%402018.md#tip)

看到slack里weiboscrapper1分享了一个计算文件夹md5sum的tip。其中`.bashrc`中实现时使用了`function dirMd5sum{}`的方法，个人觉得很棒，
一直想要实现类似的功能，搜索到的方法感觉都比较复杂。

```
#  .bashrc

function myFunc {
    find $1 -type f -print0 | xargs -0 md5sum | sort -k 2
}

# $1 是关键
```


## 4. Share


## 5.Summary

